web开发安全（攻击者）

## XSS跨站脚本攻击
攻击者将他的攻击脚本注入进网页
XSS的原因：盲目信任用户提交的内容，程序员直接把用户的字符串提交

XSS特点：难以在UI上感知
窃取用户信息
绘制UI弹窗，诱骗用户点击/填写表单


存储类XSS
恶意脚本会被存储至数据库中

反射型XSS
不涉及数据库 从URL上攻击

基于DOM的XSS攻击
不需要服务器参与

Mutation XSS 
利用了浏览器渲染DOM的特性(独特优化)
不同浏览器，会有区别（按浏览器）


## CSRF跨站伪造请求
在用户不知情
利用用户权限
构造指定的HTTP请求，窃取或修改用户敏感信息


get请求方式 a标签和img标签都可以完成


## SQL注入
读取请求字段，直接以字符串的形式拼接SQL语句


## 系统命令注入


## 正则的贪婪模式
重复匹配时 ? vs no?：“一个” vs “尽可能多”

## 基于正则表达式的Dos
使用贪婪模式的正则时候会存在回溯行为导致超时

## DDos
短时间内，来自大量僵尸设备的流量请求，服务器不能即时完成全部请求，导致请求堆积进而雪崩效应，无法响应新请求
TCP三次请求，攻击者只会发送SYN第一次链接请求


## 中间人攻击
利用的点
1. 明文传输
2. 信息篡改不可知
3. 对方身份未验证



# 防御篇

##  XSS
永远不要相信用户提交的内容
前端：
主流的前端框架都默认防御XSS
Google-closure-library
服务端（NODE）：
DOMPurify

## 如果有些用户必须要生成动态的DOM
1. 如果要直接通过String生成DOM 我们要对String进行转译
2. 如果允许用户上传SVG文件，因为SVG允许插入script标签，也就是说SVG被加载就会运行script标签
3. Blob动态生成script：尽量不要做用户自定义跳转行为，如果做也一定要做好过滤
4. 自定义样式：在css中去发送一个get请求

## SOP同源策略


## CSP
开发者定义哪些源（域名）被认为是安全的
对于安全源的脚本可以执行，否则直接报错


## CSRF的防御
限制请求来源未异常来源则拒接响应
图文请求中origin字段不会发送
可以使用Referer字段来

## CSRF token形式
攻击者也可以是注册用户 可以获取自己的token
过期时间


## CSRF iframe攻击
绕过origin限制
攻击者构造一个页面，页面上有一个button标签，button标签下有一个iframe(我们的合法页面)，导致点击行为进入iframe中，iframe发送一个http请求iframe发送的是同源请求

防御：X-Frame-Option:DENY/SAMEORIGIN开启这个响应头部（表示必须是同源的iframe才能加载这个页面）


## CSRF anti-pattern
把get用为既能获取数据又能修改数据

将更新和获取数据的逻辑放到同一个GET接口


## 避免用户信息被携带：SameSite Cookie

限制的是cookie domain 页面域名

如果一个依赖第三方服务怎么办？
例如一个内嵌X站的播放器，识别不了用户的登录状态，发不了弹幕


## SameSite vs CORS


## CSRF的正确姿势
在node中使用项目CSRF防御的中间件来实现CSRF防御

## Injection
找到项目中查询SQL的地方使用prepared statement对SQL语句进行提前编译

最小原则：
所有的命令都不要用sudo || root来拿到权限

建立允许名单 + 过滤
拒绝rm操作

对URL类型参数进行协议、域名、IP等限制


# 防御DOS
1. 代码reviwe 避免写出贪婪正则
2. 代码扫描 + 正则性能测试
3. 拒绝使用用户提供的正则

# DDOS
1. 流量治理
    1. 负责均衡
    2. API网关
    3. CDN

快速扩容
非核心业务服务降级

## 传输层--防御中间人
HTTPS 特性：
1. 可靠性：加密
2. 完成性：MAC验证
3. 不可抵赖性:数字签名


当签名算法不够健壮时 签名算法会被暴力破解


静态资源被劫持篡改 CDN被黑客攻击
SRI
在script中的integrity