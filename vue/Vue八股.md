# Computed 和 Watch 的区别
computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值
watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作


# 什么是插槽
插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的
slot又分三类，默认插槽，具名插槽和作用域插槽。

# data为什么是一个函数而不是对象
JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化
而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰
简单说：避免组件被复用时，数据存在引用关系


# 一个重要的内置关系 VueComponent.__proto__ === Vue.prototype

作用：让组件的实例对象可以访问到Vue原型上的方法


# vue-cli解决跨域问题
## 方式一
 在vue.config.js里面添加
 devServer:{
    proxy:'htt://localhost:4000' //目标服务器
 }

## 方式二
devServer:{
    proxy:{
        '/api':{ //在端口号后面多加一个/api就能让他指定发代理
            target:"<url>",
            pathRewrite:{'^/atguigu':""}//去除atgugui路劲
            ws:true,//websocket
            changeOrigin:true
        },
        '/demo':{ //在端口号后面多加一个/api就能让他指定发代理
            target:"<url>",
            pathRewrite:{'^/demo':""}//去除atgugui路劲
            ws:true,//websocket
            changeOrigin:true
        }
    }

}

# v-show和v-if区别
v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换


# 组件和插件的区别
插件的一般用途：
1. 添加全局方法和属性指令混入
2. 一个库提供自己的API如vux


# vue的8种通信方式

1. 通过 props 传递
2. 通过 $emit 触发自定义事件
3. 使用 ref
4. EventBus
   ：实际就是把一个pubsub类挂载再Vue的原型的对象上，然后这个pubsub有on方法和emit方法
5. parent或root
6. attrs 与 listeners
7. Provide 与 Inject
8. Vuex
8.1 state用来存放共享变量的地方
8.2 getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值
8.3 mutations用来存放修改state的方法。
8.4 actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作



# 什么是MVVM

1. 数据层（Model）：应用的数据及业务逻辑
2. 视图层（View）：应用的展示效果，各类UI组件
3. 业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来

实现双向绑定的原理
Observer监听器：对所有数据的属性做监听
解析器：根据指令进行数据的替换和绑定响应的更新函数


# nextTick的理解
原理：Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新
这里是根据当前环境支持什么方法则确定调用哪个，分别有：
Promise.then、MutationObserver、setImmediate、setTimeout

# mixin
mixin就是一个对象有组件的data method etc

1. 当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项

2. 但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子


# slot

子组件用<slot>标签来确定渲染的位置，标签里面可以放DOM结构，当父组件使用的时候没有往插槽传入内容，标签内DOM结构就会显示在页面

插槽分类     
1. 默认插槽 v:slot="default"
2. 具名插槽 v:slot="自定义的名字"
3. 作用域插槽 ：子组件再作用上绑定属性
插槽使用场景
复用组件的时候我们有少量需要更改的地方就可以用slot

比如布局组件、表格列、下拉选、弹框显示内容等


# 虚拟DOM
虚拟 DOM 为这两个框架都带来了跨平台的能力


# 权限管理

接口权限：接口权限目前一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录
登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token


# 路由权限控制
方案一：初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验

方案二：初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制，
登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由按需挂载


# 跨域
CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允 许的访问来源
只要后端实现了 CORS，就实现了跨域


# history和hash
history种当我们在 website.com/login 页执行刷新操作，nginx location 是没有相关配置的，所以就会出现 404 的情况
hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面



 # vue3响应式
 同时Proxy  并不能监听到内部深层次的对象变化，而 Vue3 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归


# 回流和重绘
回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置

重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制

# 什么是BFC
即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则：


# diff算法

reactdiff算法：

# 
